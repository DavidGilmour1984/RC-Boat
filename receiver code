#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>
extern "C" {
  #include "esp_wifi_types.h"
}

// ===== Pins (boat) =====
const int motorAPWM = 19;  // Y-axis PWM
const int motorADIR = 18;  // Y-axis DIR
const int motorBPWM = 5;   // X-axis PWM
const int motorBDIR = 4;   // X-axis DIR
const int VP_PIN   = 36;   // Battery divider (20k:10k on VP)

// ===== PWM config =====
const int pwmFreq = 5000;
const int pwmResolution = 8;   // 0â€“255
const int maxDuty = 254;

// ===== Comms =====
const uint8_t TRANSMITTER_MAC[6] = {0x94,0x54,0xC5,0x76,0xC8,0x90}; // Hand piece STA MAC
const uint8_t WIFI_CHANNEL = 1;
const unsigned long COMM_TIMEOUT_MS = 300;

// Optional polarity flips
const bool INVERT_A = false; // Y motor
const bool INVERT_B = false; // X motor

// ===== State =====
volatile unsigned long lastRxMs = 0;
volatile int8_t lastPeerRSSI = 127;   // updated by promiscuous callback

// ===== Battery calc =====
const float ADC_REF_V    = 3.3f;
const float DIVIDER_GAIN = 3.0f; // (20k+10k)/10k

// ===== Helpers =====
static inline void stopMotors() { ledcWrite(0, 0); ledcWrite(1, 0); }

// Map -255..255 -> dir + PWM; reverse-only duty flip
// Ensures -1 is slow, -255 is full reverse
static inline void driveMotor(int16_t cmd, int dirPin, int channel, bool invert) {
  if (invert) cmd = -cmd;
  bool rev = (cmd < 0);
  int duty = abs(cmd);
  if (duty > 255) duty = 255;
  duty = map(duty, 0, 255, 0, maxDuty); // 0..254
  if (rev) duty = maxDuty - duty;       // reverse ramp corrected
  digitalWrite(dirPin, rev ? HIGH : LOW);
  ledcWrite(channel, duty);
}

static inline uint16_t readBattery_mV(int pin) {
  analogSetPinAttenuation(pin, ADC_11db);
  int raw = analogRead(pin);
  float v_pin = (raw / 4095.0f) * ADC_REF_V;
  float v_bat = v_pin * DIVIDER_GAIN;
  return (uint16_t)lroundf(v_bat * 1000.0f);
}

// Parse CSV "cmdX,cmdY"
static bool parseCSVCmds(const char* buf, int16_t& outX, int16_t& outY) {
  int x=0, y=0;
  if (sscanf(buf, "%d,%d", &x, &y) == 2) {
    if (x < -255) x = -255; if (x > 255) x = 255;
    if (y < -255) y = -255; if (y > 255) y = 255;
    outX = (int16_t)x; outY = (int16_t)y;
    return true;
  }
  return false;
}

// Promiscuous RSSI capture (match TX MAC)
void promiscuous_rx_cb(void *buf, wifi_promiscuous_pkt_type_t type) {
  if (type != WIFI_PKT_MGMT && type != WIFI_PKT_DATA) return;
  const wifi_promiscuous_pkt_t *ppkt = (const wifi_promiscuous_pkt_t *)buf;
  const uint8_t *payload = ppkt->payload;
  const uint8_t *addr2 = payload + 10; // transmitter address
  if (memcmp(addr2, TRANSMITTER_MAC, 6) == 0) {
    lastPeerRSSI = ppkt->rx_ctrl.rssi; // dBm
  }
}

// Optional: send status callback
void onDataSent(const uint8_t* mac, esp_now_send_status_t status) {
  Serial.printf("Send to %02X:%02X:%02X:%02X:%02X:%02X -> %s\n",
                mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
                status == ESP_NOW_SEND_SUCCESS ? "SUCCESS" : "FAILED");
}

// ===== ESP-NOW callback =====
void onDataRecv(const uint8_t*, const uint8_t* data, int len) {
  static char buf[32];
  if (len <= 0) return;
  if (len >= (int)sizeof(buf)) len = sizeof(buf)-1;
  memcpy(buf, data, len);
  buf[len] = '\0';

  // Debug input
  Serial.printf("RX CSV: '%s'\n", buf);

  int16_t cmdX, cmdY;
  if (!parseCSVCmds(buf, cmdX, cmdY)) return;

  lastRxMs = millis();

  // Drive motors (Y->A, X->B)
  driveMotor(cmdY, motorADIR, 0, INVERT_A);
  driveMotor(cmdX, motorBDIR, 1, INVERT_B);

  // Send back CSV: "rssi,boatBatt_mV"
  char out[24];
  uint16_t boatBatt_mV = readBattery_mV(VP_PIN);
  snprintf(out, sizeof(out), "%d,%u", (int)lastPeerRSSI, (unsigned)boatBatt_mV);
  esp_err_t err = esp_now_send(TRANSMITTER_MAC, (uint8_t*)out, strlen(out));
  if (err != ESP_OK) {
    Serial.printf("esp_now_send error: %d\n", (int)err);
  } else {
    Serial.printf("TX CSV back: '%s'\n", out);
  }
}

void setup() {
  Serial.begin(115200);

  // Pins
  pinMode(motorADIR, OUTPUT);
  pinMode(motorBDIR, OUTPUT);
  digitalWrite(motorADIR, LOW);
  digitalWrite(motorBDIR, LOW);

  // PWM
  ledcSetup(0, pwmFreq, pwmResolution); ledcAttachPin(motorAPWM, 0); ledcWrite(0, 0);
  ledcSetup(1, pwmFreq, pwmResolution); ledcAttachPin(motorBPWM, 1); ledcWrite(1, 0);

  // WiFi / ESP-NOW (fixed channel)
  WiFi.mode(WIFI_STA);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);

  if (esp_now_init() != ESP_OK) { Serial.println("ESP-NOW init failed"); while (true){} }
  esp_now_register_recv_cb(onDataRecv);
  esp_now_register_send_cb(onDataSent);

  // Add peer (TX) so we can send back status
  esp_now_peer_info_t peer = {};
  memcpy(peer.peer_addr, TRANSMITTER_MAC, 6);
  peer.channel = WIFI_CHANNEL;
  peer.encrypt = false;
  esp_now_add_peer(&peer);

  // Enable promiscuous to capture RSSI
  wifi_promiscuous_filter_t filt{};
  filt.filter_mask = WIFI_PROMIS_FILTER_MASK_MGMT | WIFI_PROMIS_FILTER_MASK_DATA;
  esp_wifi_set_promiscuous_filter(&filt);
  esp_wifi_set_promiscuous_rx_cb(promiscuous_rx_cb);
  esp_wifi_set_promiscuous(true);

  lastRxMs = millis();
  Serial.print("Boat STA MAC: "); Serial.println(WiFi.macAddress());
  Serial.println("Boat ready. Waiting for CSV: cmdX,cmdY");
}

void loop() {
  if ((millis() - lastRxMs) > COMM_TIMEOUT_MS) {
    stopMotors();
  }
}
