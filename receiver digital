#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>

// ===== Pins (boat) =====
const int motorAPWM = 19;  // Y-axis PWM
const int motorADIR = 18;  // Y-axis DIR
const int motorBPWM = 5;   // X-axis PWM
const int motorBDIR = 4;   // X-axis DIR

// ===== PWM config =====
const int pwmFreq = 5000;
const int pwmResolution = 8;   // 0â€“255
const int maxDuty = 254;

// ===== Comms =====
const uint8_t TRANSMITTER_MAC[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}; // <-- set to TX MAC
const uint8_t WIFI_CHANNEL = 1;
const unsigned long COMM_TIMEOUT_MS = 300;

// Optional polarity flips (if a motor runs backward)
const bool INVERT_A = false; // Y motor
const bool INVERT_B = false; // X motor

// ===== State =====
volatile unsigned long lastRxMs = 0;

// ===== Helpers =====
static inline void stopMotors() { ledcWrite(0, 0); ledcWrite(1, 0); }

// Map -255..255 cmd to direction + PWM.
// Fix: some drivers effectively invert PWM in reverse.
// We counter that by flipping duty ONLY when rev==true.
static inline void driveMotor(int16_t cmd, int dirPin, int channel, bool invert) {
  if (invert) cmd = -cmd;

  bool rev = (cmd < 0);
  int duty = abs(cmd);                  // 0..255
  if (duty > 255) duty = 255;

  // base duty 0..254
  duty = map(duty, 0, 255, 0, maxDuty);

  // *** FIX: reverse-only duty flip to make -1 slow and -255 fast ***
  if (rev) duty = maxDuty - duty;

  digitalWrite(dirPin, rev ? HIGH : LOW);
  ledcWrite(channel, duty);
}

// Parse CSV "cmdX,cmdY" -> two ints
static bool parseCSVCmds(const char* buf, int16_t& outX, int16_t& outY) {
  int x=0, y=0;
  if (sscanf(buf, "%d,%d", &x, &y) == 2) {
    if (x < -255) x = -255; if (x > 255) x = 255;
    if (y < -255) y = -255; if (y > 255) y = 255;
    outX = (int16_t)x; outY = (int16_t)y;
    return true;
  }
  return false;
}

// ===== ESP-NOW callback =====
void onDataRecv(const uint8_t*, const uint8_t* data, int len) {
  static char buf[32];
  if (len <= 0) return;
  if (len >= (int)sizeof(buf)) len = sizeof(buf)-1;
  memcpy(buf, data, len);
  buf[len] = '\0';

  // Debug: print raw CSV
  Serial.printf("RX CSV: '%s'\n", buf);

  int16_t cmdX, cmdY;
  if (!parseCSVCmds(buf, cmdX, cmdY)) return;

  lastRxMs = millis();

  // Y -> Motor A, X -> Motor B
  driveMotor(cmdY, motorADIR, 0, INVERT_A);
  driveMotor(cmdX, motorBDIR, 1, INVERT_B);
}

void setup() {
  Serial.begin(115200);

  // Pins
  pinMode(motorADIR, OUTPUT);
  pinMode(motorBDIR, OUTPUT);
  digitalWrite(motorADIR, LOW);
  digitalWrite(motorBDIR, LOW);

  // PWM
  ledcSetup(0, pwmFreq, pwmResolution); ledcAttachPin(motorAPWM, 0); ledcWrite(0, 0);
  ledcSetup(1, pwmFreq, pwmResolution); ledcAttachPin(motorBPWM, 1); ledcWrite(1, 0);

  // WiFi / ESP-NOW
  WiFi.mode(WIFI_STA);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);

  if (esp_now_init() != ESP_OK) { Serial.println("ESP-NOW init failed"); while (true){} }
  esp_now_register_recv_cb(onDataRecv);

  // Add peer (TX)
  esp_now_peer_info_t peer = {};
  memcpy(peer.peer_addr, TRANSMITTER_MAC, 6);
  peer.channel = WIFI_CHANNEL;
  peer.encrypt = false;
  esp_now_add_peer(&peer);

  lastRxMs = millis();
  Serial.println("Boat ready. Waiting for CSV: cmdX,cmdY");
}

void loop() {
  if ((millis() - lastRxMs) > COMM_TIMEOUT_MS) {
    stopMotors();
  }
}
