#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h>

// ======== Pins (boat) ========
const int motorAPWM = 19;  // Y-axis PWM
const int motorADIR = 18;  // Y-axis DIR
const int motorBPWM = 5;   // X-axis PWM
const int motorBDIR = 4;   // X-axis DIR
const int VP_PIN   = 36;   // Battery divider sense (VP / ADC1_CH0)

// ======== PWM config ========
const int pwmFreq = 5000;
const int pwmResolution = 8;   // 0â€“255
const int maxDuty = 254;

// ======== Filters ========
const int hysteresis   = 10;
const int pwmThreshold = 5;

// ======== Comms control ========
const uint8_t TRANSMITTER_MAC[6] = {0xAA,0xBB,0xCC,0xDD,0xEE,0xFF}; // <--- TODO set to hand controller MAC
const uint8_t WIFI_CHANNEL = 1;
const unsigned long COMM_TIMEOUT_MS = 300;     // If no control in this window: stop motors and send status
const unsigned long STATUS_PERIOD_MS = 500;    // How often to send status while idle

// ======== Battery calc ========
const float ADC_REF_V = 3.3f;   // ESP32 ADC ref (approx)
const float DIVIDER_GAIN = 3.0f; // (20k+10k)/10k = 3.0

// ======== Message types ========
enum MsgKind : uint8_t { MSG_CTRL = 1, MSG_STATUS = 2 };

typedef struct __attribute__((packed)) {
  uint8_t  kind;       // MSG_CTRL
  uint16_t x;          // raw ADC from TX
  uint16_t y;          // raw ADC from TX
  uint16_t txBatt_mV;  // transmitter battery in mV (for future if you want it)
} CtrlPacket;

typedef struct __attribute__((packed)) {
  uint8_t  kind;          // MSG_STATUS
  uint16_t boatBatt_mV;   // boat battery in mV
} StatusPacket;

// ======== State ========
volatile unsigned long lastRxMs = 0;
int lastRawY = 2000, lastRawX = 2000;
int lastPWMA = 0, lastPWMB = 0;
unsigned long lastStatusSendMs = 0;

// ======== Helpers ========
static inline uint16_t readBattery_mV(int pin) {
  analogSetPinAttenuation(pin, ADC_11db);         // up to ~3.6V on ADC
  int raw = analogRead(pin);                      // 0..4095
  float v_pin = (raw / 4095.0f) * ADC_REF_V;      // volts at VP
  float v_bat = v_pin * DIVIDER_GAIN;             // undo divider
  return (uint16_t)roundf(v_bat * 1000.0f);       // mV
}

void stopMotorsIfRunning() {
  if (lastPWMA != 0) { ledcWrite(0, 0); lastPWMA = 0; }
  if (lastPWMB != 0) { ledcWrite(1, 0); lastPWMB = 0; }
}

void setMotor(int raw, int& lastRaw, int& lastPWM, int pwmPin, int dirPin, int channel, const char* label) {
  if (abs(raw - lastRaw) < hysteresis) { lastRaw = raw; return; }

  int speed = 0; bool reverse = false;
  if (raw > 1780) {
    int duty = map(raw, 1781, 4095, 0, 20);
    speed = duty * 12 + 1;    // up to ~241
    reverse = false;
  } else if (raw < 1660) {
    speed = map(raw, 1659, 0, maxDuty, 0);
    reverse = true;
  } else {
    speed = 0;
  }

  if (abs(speed - lastPWM) > pwmThreshold || speed == 0) {
    digitalWrite(dirPin, reverse ? HIGH : LOW);
    ledcWrite(channel, speed);
    lastPWM = speed;
    Serial.printf("%s RAW:%d -> %s | PWM:%d\n", label, raw, reverse ? "REV" : "FWD", speed);
  }
  lastRaw = raw;
}

// ======== ESP-NOW Callbacks ========
void onDataRecv(const uint8_t*, const uint8_t* data, int len) {
  if (len < (int)sizeof(CtrlPacket)) return;
  const CtrlPacket* pkt = (const CtrlPacket*)data;
  if (pkt->kind != MSG_CTRL) return;

  lastRxMs = millis();
  setMotor(pkt->y, lastRawY, lastPWMA, motorAPWM, motorADIR, 0, "Motor A (Y)");
  setMotor(pkt->x, lastRawX, lastPWMB, motorBPWM, motorBDIR, 1, "Motor B (X)");
}

void setup() {
  Serial.begin(115200);

  // Pins
  pinMode(motorADIR, OUTPUT);
  pinMode(motorBDIR, OUTPUT);
  digitalWrite(motorADIR, LOW);
  digitalWrite(motorBDIR, LOW);

  // PWM
  ledcSetup(0, pwmFreq, pwmResolution); ledcAttachPin(motorAPWM, 0); ledcWrite(0, 0);
  ledcSetup(1, pwmFreq, pwmResolution); ledcAttachPin(motorBPWM, 1); ledcWrite(1, 0);

  // WiFi / ESP-NOW
  WiFi.mode(WIFI_STA);
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);

  if (esp_now_init() != ESP_OK) { Serial.println("ESP-NOW init failed"); while (true){} }
  esp_now_register_recv_cb(onDataRecv);

  // Add peer (transmitter) so we can send status when idle
  esp_now_peer_info_t peer = {};
  memcpy(peer.peer_addr, TRANSMITTER_MAC, 6);
  peer.channel = WIFI_CHANNEL;
  peer.encrypt = false;
  esp_now_add_peer(&peer);

  lastRxMs = millis();
  Serial.println("Boat ready.");
}

void loop() {
  unsigned long now = millis();
  bool commsIdle = (now - lastRxMs) > COMM_TIMEOUT_MS;

  // If idle: stop motors and send periodic status (battery) back to TX
  if (commsIdle) {
    stopMotorsIfRunning();

    if (now - lastStatusSendMs >= STATUS_PERIOD_MS) {
      lastStatusSendMs = now;
      StatusPacket s{};
      s.kind = MSG_STATUS;
      s.boatBatt_mV = readBattery_mV(VP_PIN);
      esp_now_send(TRANSMITTER_MAC, (uint8_t*)&s, sizeof(s));
      Serial.printf("Idle: sent status, boatBatt=%u mV\n", s.boatBatt_mV);
    }
  }
}
